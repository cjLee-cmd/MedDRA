# MedDRA 데이터 추출 및 프로그래밍 가이드

## 개요

MedDRA 데이터를 프로그래밍 방식으로 읽고 활용하는 방법을 설명합니다.

---

## 파일 파싱 기본

### 파일 형식 요약

- **구분자**: `$` (달러 기호)
- **인코딩**: UTF-8
- **라인 종료**: Unix-style (LF)
- **헤더**: 없음 (첫 줄부터 데이터)
- **빈 필드**: 연속된 `$$`

### 주의사항

1. **빈 필드 처리**: `10000081$복통$$10017947$$$$$$$$`
   - 연속된 `$$`를 올바르게 파싱해야 함
   - Split 시 빈 문자열 유지 필요

2. **특수 문자**: 용어명에 `$`가 포함되지 않음 (구분자로 사용되므로)

3. **인코딩**: UTF-8 필수 (한글 처리)

---

## Python 구현 예제

### 1. 기본 파일 읽기

```python
import csv
from typing import Dict, List

def read_meddra_file(filepath: str, encoding='utf-8') -> List[List[str]]:
    """
    MedDRA 파일 읽기

    Args:
        filepath: 파일 경로
        encoding: 인코딩 (기본 UTF-8)

    Returns:
        2차원 리스트 (각 행이 필드 리스트)
    """
    data = []
    with open(filepath, 'r', encoding=encoding) as f:
        for line in f:
            # 줄바꿈 제거 후 $ 기준 split
            # -1을 사용하여 빈 필드 유지
            fields = line.strip().split('$')
            data.append(fields)
    return data


# 사용 예
llt_data = read_meddra_file('ascii-281/llt.asc')
print(f"총 {len(llt_data)}개의 LLT")
print(f"첫 번째 LLT: {llt_data[0]}")
```

### 2. LLT 딕셔너리 생성

```python
class LLTLoader:
    """LLT 데이터 로더"""

    def __init__(self, llt_file: str):
        self.llt_dict = {}
        self.pt_to_llts = {}
        self._load(llt_file)

    def _load(self, llt_file: str):
        """LLT 파일 로드"""
        with open(llt_file, 'r', encoding='utf-8') as f:
            for line in f:
                fields = line.strip().split('$')

                llt_code = fields[0]
                llt_name = fields[1]
                pt_code = fields[2]
                llt_currency = fields[9]

                # 현재 사용 중인 용어만 저장
                if llt_currency == 'Y':
                    self.llt_dict[llt_code] = {
                        'llt_name': llt_name,
                        'pt_code': pt_code
                    }

                    # PT별 LLT 매핑
                    if pt_code not in self.pt_to_llts:
                        self.pt_to_llts[pt_code] = []
                    self.pt_to_llts[pt_code].append(llt_code)

    def search_by_name(self, keyword: str) -> List[Dict]:
        """용어명으로 검색"""
        results = []
        for llt_code, info in self.llt_dict.items():
            if keyword in info['llt_name']:
                results.append({
                    'llt_code': llt_code,
                    'llt_name': info['llt_name'],
                    'pt_code': info['pt_code']
                })
        return results

    def get_llts_by_pt(self, pt_code: str) -> List[str]:
        """PT 코드로 모든 LLT 조회"""
        return self.pt_to_llts.get(pt_code, [])


# 사용 예
llt_loader = LLTLoader('ascii-281/llt.asc')

# 검색
results = llt_loader.search_by_name('두통')
for r in results:
    print(f"{r['llt_code']}: {r['llt_name']} → PT {r['pt_code']}")
```

### 3. PT 데이터 로더

```python
class PTLoader:
    """PT 데이터 로더"""

    def __init__(self, pt_file: str):
        self.pt_dict = {}
        self._load(pt_file)

    def _load(self, pt_file: str):
        """PT 파일 로드"""
        with open(pt_file, 'r', encoding='utf-8') as f:
            for line in f:
                fields = line.strip().split('$')

                pt_code = fields[0]
                pt_name = fields[1]
                pt_soc_code = fields[3]

                self.pt_dict[pt_code] = {
                    'pt_name': pt_name,
                    'pt_soc_code': pt_soc_code
                }

    def get_pt_info(self, pt_code: str) -> Dict:
        """PT 정보 조회"""
        return self.pt_dict.get(pt_code)

    def search_by_name(self, keyword: str) -> List[Dict]:
        """PT명으로 검색"""
        results = []
        for pt_code, info in self.pt_dict.items():
            if keyword in info['pt_name']:
                results.append({
                    'pt_code': pt_code,
                    'pt_name': info['pt_name'],
                    'soc_code': info['pt_soc_code']
                })
        return results


# 사용 예
pt_loader = PTLoader('ascii-281/pt.asc')
pt_info = pt_loader.get_pt_info('10019211')
print(f"PT: {pt_info['pt_name']}, SOC: {pt_info['pt_soc_code']}")
```

### 4. 계층 정보 로더 (mdhier.asc)

```python
class HierarchyLoader:
    """MedDRA 계층 정보 로더"""

    def __init__(self, mdhier_file: str):
        self.hierarchy_dict = {}
        self._load(mdhier_file)

    def _load(self, mdhier_file: str):
        """mdhier 파일 로드"""
        with open(mdhier_file, 'r', encoding='utf-8') as f:
            for line in f:
                fields = line.strip().split('$')

                pt_code = fields[0]
                hlt_code = fields[1]
                hlgt_code = fields[2]
                soc_code = fields[3]
                pt_name = fields[4]
                hlt_name = fields[5]
                hlgt_name = fields[6]
                soc_name = fields[7]
                soc_abbrev = fields[8]
                primary_soc_flag = fields[10]

                # PT 코드를 키로 하되, Primary/Secondary 구분
                if pt_code not in self.hierarchy_dict:
                    self.hierarchy_dict[pt_code] = {
                        'primary': None,
                        'secondary': []
                    }

                hierarchy_info = {
                    'pt_code': pt_code,
                    'pt_name': pt_name,
                    'hlt_code': hlt_code,
                    'hlt_name': hlt_name,
                    'hlgt_code': hlgt_code,
                    'hlgt_name': hlgt_name,
                    'soc_code': soc_code,
                    'soc_name': soc_name,
                    'soc_abbrev': soc_abbrev
                }

                if primary_soc_flag == 'Y':
                    self.hierarchy_dict[pt_code]['primary'] = hierarchy_info
                else:
                    self.hierarchy_dict[pt_code]['secondary'].append(hierarchy_info)

    def get_hierarchy(self, pt_code: str, primary_only=True) -> Dict:
        """
        PT 코드의 계층 정보 조회

        Args:
            pt_code: PT 코드
            primary_only: Primary SOC만 반환할지 여부

        Returns:
            계층 정보 딕셔너리
        """
        if pt_code not in self.hierarchy_dict:
            return None

        if primary_only:
            return self.hierarchy_dict[pt_code]['primary']
        else:
            return self.hierarchy_dict[pt_code]

    def get_pts_by_soc(self, soc_code: str) -> List[str]:
        """특정 SOC의 모든 PT 찾기"""
        pt_codes = []
        for pt_code, info in self.hierarchy_dict.items():
            if info['primary'] and info['primary']['soc_code'] == soc_code:
                pt_codes.append(pt_code)
        return pt_codes


# 사용 예
hier_loader = HierarchyLoader('ascii-281/mdhier.asc')

# 두통의 계층 정보
headache_hier = hier_loader.get_hierarchy('10019211')
print(f"PT: {headache_hier['pt_name']}")
print(f"HLT: {headache_hier['hlt_name']}")
print(f"HLGT: {headache_hier['hlgt_name']}")
print(f"SOC: {headache_hier['soc_name']}")

# 신경계 장애의 모든 PT
nervous_pts = hier_loader.get_pts_by_soc('10029205')
print(f"신경계 장애 PT 개수: {len(nervous_pts)}")
```

### 5. 통합 검색 시스템

```python
class MedDRASearch:
    """MedDRA 통합 검색 시스템"""

    def __init__(self, data_dir: str):
        """
        Args:
            data_dir: ascii-281/ 폴더 경로
        """
        self.llt_loader = LLTLoader(f'{data_dir}/llt.asc')
        self.pt_loader = PTLoader(f'{data_dir}/pt.asc')
        self.hier_loader = HierarchyLoader(f'{data_dir}/mdhier.asc')

    def search_symptom(self, symptom: str) -> List[Dict]:
        """
        증상으로 MedDRA 코드 검색

        Args:
            symptom: 증상 텍스트 (예: "두통")

        Returns:
            검색 결과 리스트
        """
        results = []

        # 1. LLT 검색
        llt_matches = self.llt_loader.search_by_name(symptom)

        for llt in llt_matches:
            pt_code = llt['pt_code']

            # 2. PT 정보 조회
            pt_info = self.pt_loader.get_pt_info(pt_code)

            # 3. 계층 정보 조회
            hierarchy = self.hier_loader.get_hierarchy(pt_code)

            if hierarchy:
                results.append({
                    'llt_code': llt['llt_code'],
                    'llt_name': llt['llt_name'],
                    'pt_code': pt_code,
                    'pt_name': pt_info['pt_name'],
                    'soc_code': hierarchy['soc_code'],
                    'soc_name': hierarchy['soc_name'],
                    'hierarchy': hierarchy
                })

        return results

    def get_related_symptoms(self, pt_code: str) -> List[Dict]:
        """
        같은 HLT의 관련 증상 찾기

        Args:
            pt_code: PT 코드

        Returns:
            관련 증상 리스트
        """
        # 현재 PT의 HLT 코드 확인
        hierarchy = self.hier_loader.get_hierarchy(pt_code)
        if not hierarchy:
            return []

        hlt_code = hierarchy['hlt_code']

        # 같은 HLT의 다른 PT들 찾기
        related_pts = []
        for pt, info in self.hier_loader.hierarchy_dict.items():
            if info['primary'] and info['primary']['hlt_code'] == hlt_code and pt != pt_code:
                pt_info = self.pt_loader.get_pt_info(pt)
                related_pts.append({
                    'pt_code': pt,
                    'pt_name': pt_info['pt_name']
                })

        return related_pts


# 사용 예
search = MedDRASearch('ascii-281')

# 증상 검색
results = search.search_symptom('두통')
for r in results:
    print(f"LLT: {r['llt_name']} ({r['llt_code']})")
    print(f"PT: {r['pt_name']} ({r['pt_code']})")
    print(f"SOC: {r['soc_name']}")
    print("---")

# 관련 증상 찾기
related = search.get_related_symptoms('10019211')
print(f"\n'두통'과 관련된 증상들:")
for r in related[:5]:
    print(f"- {r['pt_name']} ({r['pt_code']})")
```

---

## SMQ 데이터 로더

### SMQ 검색 시스템

```python
class SMQLoader:
    """SMQ 데이터 로더"""

    def __init__(self, smq_list_file: str, smq_content_file: str):
        self.smq_list = {}
        self.smq_content = {}
        self._load_list(smq_list_file)
        self._load_content(smq_content_file)

    def _load_list(self, smq_list_file: str):
        """SMQ 목록 로드"""
        with open(smq_list_file, 'r', encoding='utf-8') as f:
            for line in f:
                fields = line.strip().split('$')

                smq_code = fields[0]
                smq_name = fields[1]
                smq_level = fields[2]
                smq_description = fields[3]

                self.smq_list[smq_code] = {
                    'name': smq_name,
                    'level': smq_level,
                    'description': smq_description
                }

    def _load_content(self, smq_content_file: str):
        """SMQ 내용 로드"""
        with open(smq_content_file, 'r', encoding='utf-8') as f:
            for line in f:
                fields = line.strip().split('$')

                smq_code = fields[0]
                term_code = fields[1]
                term_level = fields[2]
                term_scope = fields[3]

                if smq_code not in self.smq_content:
                    self.smq_content[smq_code] = {
                        'narrow_pt': [],
                        'broad_pt': [],
                        'narrow_llt': [],
                        'broad_llt': []
                    }

                # PT
                if term_level == '4':
                    if term_scope == '2':  # Narrow
                        self.smq_content[smq_code]['narrow_pt'].append(term_code)
                    elif term_scope == '1':  # Broad
                        self.smq_content[smq_code]['broad_pt'].append(term_code)

                # LLT
                elif term_level == '5':
                    if term_scope == '2':
                        self.smq_content[smq_code]['narrow_llt'].append(term_code)
                    elif term_scope == '1':
                        self.smq_content[smq_code]['broad_llt'].append(term_code)

    def get_smq_info(self, smq_code: str) -> Dict:
        """SMQ 정보 조회"""
        return self.smq_list.get(smq_code)

    def get_smq_terms(self, smq_code: str, scope='narrow', level='pt') -> List[str]:
        """
        SMQ 용어 조회

        Args:
            smq_code: SMQ 코드
            scope: 'narrow' 또는 'broad'
            level: 'pt' 또는 'llt'

        Returns:
            용어 코드 리스트
        """
        if smq_code not in self.smq_content:
            return []

        key = f'{scope}_{level}'
        return self.smq_content[smq_code].get(key, [])

    def search_smq_by_name(self, keyword: str) -> List[Dict]:
        """SMQ 이름으로 검색"""
        results = []
        for smq_code, info in self.smq_list.items():
            if keyword in info['name']:
                results.append({
                    'smq_code': smq_code,
                    'smq_name': info['name'],
                    'smq_level': info['level']
                })
        return results

    def check_pt_in_smq(self, pt_code: str, smq_code: str, scope='narrow') -> bool:
        """PT가 특정 SMQ에 포함되는지 확인"""
        terms = self.get_smq_terms(smq_code, scope=scope, level='pt')
        return pt_code in terms


# 사용 예
smq_loader = SMQLoader('ascii-281/smq_list.asc', 'ascii-281/smq_content.asc')

# 간 장애 SMQ 검색
liver_smqs = smq_loader.search_smq_by_name('간')
for smq in liver_smqs:
    print(f"{smq['smq_code']}: {smq['smq_name']} (Level {smq['smq_level']})")

# 간 장애 SMQ의 Narrow PT들
liver_pts_narrow = smq_loader.get_smq_terms('20000005', scope='narrow', level='pt')
print(f"\n간 장애 SMQ Narrow PT: {len(liver_pts_narrow)}개")

# 특정 PT가 간 장애 SMQ에 포함되는지 확인
is_liver_ae = smq_loader.check_pt_in_smq('10019692', '20000005', scope='narrow')
print(f"PT 10019692가 간 장애 SMQ에 포함: {is_liver_ae}")
```

---

## 성능 최적화

### 1. 인덱스 구축

```python
import pickle

class MedDRAIndexBuilder:
    """MedDRA 인덱스 빌더 (캐싱)"""

    def __init__(self, data_dir: str):
        self.data_dir = data_dir

    def build_indexes(self, output_file: str):
        """인덱스 파일 생성"""
        print("Loading data...")
        llt_loader = LLTLoader(f'{self.data_dir}/llt.asc')
        pt_loader = PTLoader(f'{self.data_dir}/pt.asc')
        hier_loader = HierarchyLoader(f'{self.data_dir}/mdhier.asc')

        indexes = {
            'llt': llt_loader,
            'pt': pt_loader,
            'hierarchy': hier_loader
        }

        print(f"Saving indexes to {output_file}...")
        with open(output_file, 'wb') as f:
            pickle.dump(indexes, f)

        print("Done!")

    @staticmethod
    def load_indexes(index_file: str) -> Dict:
        """인덱스 파일 로드"""
        with open(index_file, 'rb') as f:
            return pickle.load(f)


# 인덱스 빌드 (1회만)
builder = MedDRAIndexBuilder('ascii-281')
builder.build_indexes('meddra_indexes.pkl')

# 이후 빠른 로드
indexes = MedDRAIndexBuilder.load_indexes('meddra_indexes.pkl')
llt_loader = indexes['llt']
pt_loader = indexes['pt']
hier_loader = indexes['hierarchy']
```

### 2. SQLite 데이터베이스 구축

```python
import sqlite3

class MedDRADatabase:
    """MedDRA SQLite 데이터베이스 생성기"""

    def __init__(self, db_file: str):
        self.conn = sqlite3.connect(db_file)
        self.cursor = self.conn.cursor()

    def create_tables(self):
        """테이블 생성"""

        # LLT 테이블
        self.cursor.execute('''
            CREATE TABLE IF NOT EXISTS llt (
                llt_code TEXT PRIMARY KEY,
                llt_name TEXT,
                pt_code TEXT,
                llt_currency TEXT
            )
        ''')

        # PT 테이블
        self.cursor.execute('''
            CREATE TABLE IF NOT EXISTS pt (
                pt_code TEXT PRIMARY KEY,
                pt_name TEXT,
                pt_soc_code TEXT
            )
        ''')

        # 계층 테이블
        self.cursor.execute('''
            CREATE TABLE IF NOT EXISTS hierarchy (
                pt_code TEXT,
                hlt_code TEXT,
                hlgt_code TEXT,
                soc_code TEXT,
                pt_name TEXT,
                hlt_name TEXT,
                hlgt_name TEXT,
                soc_name TEXT,
                soc_abbrev TEXT,
                primary_soc_flag TEXT
            )
        ''')

        # 인덱스 생성
        self.cursor.execute('CREATE INDEX IF NOT EXISTS idx_llt_name ON llt(llt_name)')
        self.cursor.execute('CREATE INDEX IF NOT EXISTS idx_pt_name ON pt(pt_name)')

        self.conn.commit()

    def import_llt(self, llt_file: str):
        """LLT 데이터 임포트"""
        with open(llt_file, 'r', encoding='utf-8') as f:
            for line in f:
                fields = line.strip().split('$')
                self.cursor.execute('''
                    INSERT OR REPLACE INTO llt VALUES (?, ?, ?, ?)
                ''', (fields[0], fields[1], fields[2], fields[9]))
        self.conn.commit()

    def search_symptom(self, keyword: str):
        """증상 검색 (SQL)"""
        self.cursor.execute('''
            SELECT l.llt_code, l.llt_name, l.pt_code, p.pt_name, h.soc_name
            FROM llt l
            JOIN pt p ON l.pt_code = p.pt_code
            JOIN hierarchy h ON p.pt_code = h.pt_code
            WHERE l.llt_name LIKE ? AND l.llt_currency = 'Y' AND h.primary_soc_flag = 'Y'
        ''', (f'%{keyword}%',))

        return self.cursor.fetchall()


# 사용 예
db = MedDRADatabase('meddra.db')
db.create_tables()
db.import_llt('ascii-281/llt.asc')

# 검색
results = db.search_symptom('두통')
for r in results:
    print(f"LLT: {r[1]}, PT: {r[3]}, SOC: {r[4]}")
```

---

## REST API 서버 예제

### Flask 기반 API

```python
from flask import Flask, jsonify, request
from meddra_search import MedDRASearch

app = Flask(__name__)
search = MedDRASearch('ascii-281')

@app.route('/api/search', methods=['GET'])
def api_search():
    """증상 검색 API"""
    keyword = request.args.get('keyword', '')

    if not keyword:
        return jsonify({'error': 'keyword parameter required'}), 400

    results = search.search_symptom(keyword)
    return jsonify({
        'keyword': keyword,
        'count': len(results),
        'results': results
    })

@app.route('/api/hierarchy/<pt_code>', methods=['GET'])
def api_hierarchy(pt_code):
    """계층 정보 조회 API"""
    hierarchy = search.hier_loader.get_hierarchy(pt_code)

    if not hierarchy:
        return jsonify({'error': 'PT code not found'}), 404

    return jsonify(hierarchy)

@app.route('/api/related/<pt_code>', methods=['GET'])
def api_related(pt_code):
    """관련 증상 조회 API"""
    related = search.get_related_symptoms(pt_code)
    return jsonify({
        'pt_code': pt_code,
        'count': len(related),
        'related_symptoms': related
    })

if __name__ == '__main__':
    app.run(debug=True, port=5000)
```

**API 사용 예:**
```bash
# 증상 검색
curl "http://localhost:5000/api/search?keyword=두통"

# 계층 정보
curl "http://localhost:5000/api/hierarchy/10019211"

# 관련 증상
curl "http://localhost:5000/api/related/10019211"
```

---

## 다음 단계

이제 기본적인 MedDRA 데이터 활용 방법을 모두 익혔습니다!

### 추가 학습 자료
- [00_개요.md](00_개요.md) - 전체 시스템 개요
- 원본 PDF 문서들 (`dist_file_format_28_1_Korean.pdf` 등)

### 실무 적용
1. 환자 증상 입력 인터페이스 구축
2. 부작용 보고서 자동 코딩 시스템
3. 약물감시 데이터베이스 구축
4. SMQ 기반 신호 탐지 시스템
